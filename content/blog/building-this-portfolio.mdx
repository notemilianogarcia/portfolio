---
title: "Building This Portfolio"
summary: "Why I built this site and what it represents: a curated space to share projects, ideas, and a glimpse into how I think and work."
date: "2026-01-27"
tags: ["frontend", "Next.js", "TypeScript", "MDX", "Personal"]
---

# Building This Portfolio

This website is more than a place to list projects. It's a system for presenting technical work, research, and writing in a way that reflects how I think about engineering: clearly, intentionally, and with attention to the details that make software maintainable over time.

Building a portfolio from scratch instead of using a template was not about novelty. It was about control. Templates prioritize visual flexibility over content structure, and most assume a content management system or dynamic rendering. I needed something simpler: a static site that treats content as data, keeps versioning straightforward, and lets me iterate on the presentation layer without touching the content itself.

## Why build custom

The decision to build from scratch came down to a few key priorities.

First, I wanted full control over how content is authored and structured. Writing in Markdown with frontmatter is simple, readable, and version-controlled by default. No database, no CMS, no API layer. Just files that can be edited anywhere and tracked with standard git workflows.

Second, I wanted the architecture to support long-term iteration. Projects, publications, and blog posts all follow the same pattern: metadata-driven, statically generated, and composable. Adding a new post or project means creating a file, not updating configuration or migrating data.

Third, I wanted the site itself to demonstrate how I approach frontend work. Every design decision, from the tag color system to the theme toggle mechanism, reflects values I apply to systems beyond the frontend: clarity, composability, and performance.

## Content-driven architecture

The site is organized around a file-based content system. Each piece of content lives in a Markdown file with YAML frontmatter for metadata. A lightweight content loader reads these files at build time, parses the frontmatter, and sorts by date. There is no runtime content fetching.

This structure separates content from presentation completely. The same content file can be rendered as a card, a full page, or an API response without modification. Components consume content as typed data, not as raw markup. This makes refactoring safe and makes the rendering layer testable.

MDX extends this model by allowing components to live inside content. A blog post can include a custom figure, a collapsible section, or an interactive demo without breaking out of the content workflow. The rendering layer handles these components transparently.

## Engineering perspective

Frontend engineering is often dismissed as superficial, but the same principles that matter in backend systems apply here: modularity, composability, and performance.

The component library is built on clear contracts. Each component has a defined interface, handles its own state, and composes predictably. The tag system, for example, groups tags by category, assigns colors based on type, and handles overflow gracefully. These behaviors are encapsulated, not scattered across the codebase.

Performance is not an afterthought. Every page is statically generated at build time. No database queries, no API calls, no client-side data fetching. The site loads instantly from a CDN. Dark and light themes are handled via CSS custom properties, requiring zero JavaScript. These are not optimizations; they are consequences of architectural choices made early.

The design itself reflects system thinking. The tag color system is inspired by IDE syntax highlighting: orange for ML, blue for backend, green for languages. This is not decoration. It is a visual signal that maps to how engineers categorize work. The split card interaction: clickable titles, selectable tags, respects user intent and demonstrates that small interaction details matter.

## What this demonstrates

This project shows how I approach systems when clarity and maintainability matter more than novelty.

It demonstrates content architecture: how to structure information so it can be consumed, reused, and version-controlled without complexity. It demonstrates frontend discipline: building components that compose predictably, styling systems that remain readable, and performance patterns that scale. It demonstrates technical communication: how to present work clearly, with context, without overstating or underselling.

It also reflects a broader philosophy: good systems are boring. They do not surprise you. They do what they are supposed to do, and they make it easy to iterate.

## Final thoughts

This website is not static. As projects evolve, as writing accumulates, as priorities shift, the site will adapt. The architecture supports that. New components can be added without rewriting the content system. New content can be published without touching the rendering layer. The design can be refined without breaking existing functionality.

The portfolio is part of my broader body of work, but it also serves a specific purpose: it is the place where everything comes together. Projects, publications, experiments, and reflections all live here, structured and accessible.

The technical details are available in the repository, and the project page covers the implementation specifics. This post explains why the site was built this way and what it demonstrates about how I work.

<div className="mt-12 pt-8 border-t border-border">
	<div className="flex flex-wrap gap-4">
		<a 
			href="https://github.com/notemilianogarcia/portfolio"
			target="_blank"
			rel="noopener noreferrer"
			className="inline-flex items-center gap-2 rounded-lg bg-accent px-6 py-3 text-sm font-bold text-bg hover:opacity-90 transition-opacity"
		>
			<svg className="w-5 h-5 shrink-0" fill="currentColor" viewBox="0 0 24 24">
				<path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v 3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
			</svg>
			<span>View on GitHub</span>
		</a>
		<a 
			href="/projects/portfolio-website"
			className="inline-flex items-center gap-2 rounded-lg px-6 py-3 text-sm font-bold text-bg hover:opacity-90 transition-opacity"
			style={{ backgroundColor: '#FF5370' }}
		>
			<svg className="w-5 h-5 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
				<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
			</svg>
			<span>View Project Page</span>
		</a>
	</div>
</div>
